<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kuaterniyon Tabanlı Uzaysal Hareket Görselleştiricisi</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 900px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        
        .visualization-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            height: 500px;
            position: relative;
            overflow: hidden;
        }
        
        #three-container {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .explanation-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            overflow-y: auto;
            max-height: 500px;
        }
        
        h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #fdbb2d;
            border-bottom: 1px solid rgba(253, 187, 45, 0.3);
            padding-bottom: 10px;
        }
        
        h3 {
            font-size: 1.4rem;
            margin: 25px 0 15px;
            color: #b21f1f;
        }
        
        p {
            line-height: 1.7;
            margin-bottom: 15px;
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            border-left: 4px solid #fdbb2d;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        
        .control-group {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }
        
        .value-display {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .concept-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 40px;
        }
        
        .card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        
        .card h3 {
            color: #fdbb2d;
            margin-top: 0;
            font-size: 1.3rem;
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        button {
            background: linear-gradient(to right, #b21f1f, #fdbb2d);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            border-bottom: 3px solid #fdbb2d;
            color: #fdbb2d;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Kuaterniyon Tabanlı Uzaysal Hareket Görselleştiricisi</h1>
            <p class="subtitle">Geometrik Cebir ve Kuaterniyonlar Kullanarak 3B Uzayda Hareket ve Dönüşümleri Anlama</p>
        </header>
        
        <div class="tabs">
            <div class="tab active" data-tab="quaternions">Kuaterniyonlar</div>
            <div class="tab" data-tab="geometric-algebra">Geometrik Cebir</div>
            <div class="tab" data-tab="dual-quaternions">Dual Kuaterniyonlar</div>
            <div class="tab" data-tab="applications">Uygulamalar</div>
        </div>
        
        <div class="content">
            <div class="visualization-panel">
                <div id="three-container"></div>
            </div>
            
            <div class="explanation-panel">
                <div id="quaternions-content" class="tab-content active">
                    <h2>Kuaterniyonlar ve 3B Dönüşümler</h2>
                    <p>Kuaterniyonlar, 3B uzayda dönüşümleri temsil etmek için kullanılan dört bileşenli sayılardır. Euler açılarına kıyasla Gimbal Lock sorununu önlerler.</p>
                    
                    <div class="math-formula">
                        q = a + bi + cj + dk
                    </div>
                    
                    <p>Burada a, b, c, d gerçek sayılar ve i, j, k sanal birimlerdir ve şu kurallara uyar:</p>
                    
                    <div class="math-formula">
                        i² = j² = k² = ijk = -1
                    </div>
                    
                    <h3>Kuaterniyon ile Dönüşüm</h3>
                    <p>Bir v vektörünü q kuaterniyonu ile döndürmek için:</p>
                    
                    <div class="math-formula">
                        v' = q v q⁻¹
                    </div>
                    
                    <p>Burada q⁻¹, q'nun eşlenik kuaterniyonudur.</p>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label for="rotation-angle">Dönüş Açısı (θ):</label>
                            <input type="range" id="rotation-angle" min="0" max="360" value="0">
                            <div class="value-display">0°</div>
                        </div>
                        
                        <div class="control-group">
                            <label for="rotation-axis">Dönüş Ekseni:</label>
                            <select id="rotation-axis">
                                <option value="x">X Ekseni</option>
                                <option value="y">Y Ekseni</option>
                                <option value="z">Z Ekseni</option>
                                <option value="custom">Özel Eksen</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <button id="animate-rotation">Dönüşümü Canlandır</button>
                            <button id="reset-rotation">Sıfırla</button>
                        </div>
                    </div>
                </div>
                
                <div id="geometric-algebra-content" class="tab-content">
                    <h2>Geometrik Cebir Temelleri</h2>
                    <p>Geometrik cebir, vektörleri, bivektörleri (düzlemler) ve trivektörleri (hacimler) tek bir matematiksel çerçevede birleştirir.</p>
                    
                    <h3>Geometrik Çarpım</h3>
                    <p>İki vektörün geometrik çarpımı, iç çarpım ve dış çarpımın birleşimidir:</p>
                    
                    <div class="math-formula">
                        uv = ⟨u, v⟩ + u∧v
                    </div>
                    
                    <p>Burada ⟨u, v⟩ skaler (iç çarpım), u∧v ise bivektördür (dış çarpım).</p>
                    
                    <h3>Kuaterniyonlar ve Geometrik Cebir İlişkisi</h3>
                    <p>Geometrik cebir G(3,0)'daki skaler ve bivektörlerden oluşan alt uzay, kuaterniyon cebiriyle izomorfiktir:</p>
                    
                    <div class="math-formula">
                        1 ↔ 1,  e₁∧e₂ ↔ i,  e₂∧e₃ ↔ j,  e₃∧e₁ ↔ k
                    </div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label for="vector-u">Vektör u:</label>
                            <input type="range" id="vector-u-x" min="-1" max="1" step="0.1" value="1">
                            <div class="value-display">x: 1.0</div>
                            <input type="range" id="vector-u-y" min="-1" max="1" step="0.1" value="0">
                            <div class="value-display">y: 0.0</div>
                            <input type="range" id="vector-u-z" min="-1" max="1" step="0.1" value="0">
                            <div class="value-display">z: 0.0</div>
                        </div>
                        
                        <div class="control-group">
                            <label for="vector-v">Vektör v:</label>
                            <input type="range" id="vector-v-x" min="-1" max="1" step="0.1" value="0">
                            <div class="value-display">x: 0.0</div>
                            <input type="range" id="vector-v-y" min="-1" max="1" step="0.1" value="1">
                            <div class="value-display">y: 1.0</div>
                            <input type="range" id="vector-v-z" min="-1" max="1" step="0.1" value="0">
                            <div class="value-display">z: 0.0</div>
                        </div>
                    </div>
                </div>
                
                <div id="dual-quaternions-content" class="tab-content">
                    <h2>Dual Kuaterniyonlar</h2>
                    <p>Dual kuaterniyonlar, hem dönüşüm hem de ötelemeyi tek bir matematiksel yapıda birleştirir.</p>
                    
                    <div class="math-formula">
                        Q = q + εq_d
                    </div>
                    
                    <p>Burada q dönüşümü, q_d ise ötelemeyi temsil eder. ε dual birimdir ve ε² = 0 kuralına uyar.</p>
                    
                    <h3>Vida Hareketi (Screw Motion)</h3>
                    <p>Dual kuaterniyonlar, bir eksen etrafında dönme ve aynı eksen boyunca öteleme hareketini (vida hareketi) temsil edebilir.</p>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label for="screw-angle">Vida Açısı:</label>
                            <input type="range" id="screw-angle" min="0" max="360" value="0">
                            <div class="value-display">0°</div>
                        </div>
                        
                        <div class="control-group">
                            <label for="screw-translation">Öteleme Miktarı:</label>
                            <input type="range" id="screw-translation" min="0" max="5" step="0.1" value="0">
                            <div class="value-display">0.0 birim</div>
                        </div>
                        
                        <div class="control-group">
                            <button id="animate-screw">Vida Hareketini Canlandır</button>
                        </div>
                    </div>
                </div>
                
                <div id="applications-content" class="tab-content">
                    <h2>Uygulama Alanları</h2>
                    <p>Kuaterniyon tabanlı yöntemler çeşitli alanlarda kullanılmaktadır:</p>
                    
                    <h3>Robotik</h3>
                    <p>Robot kollarının hareket planlamasında, kuaterniyonlar dönüşümlerin pürüzsüz bir şekilde enterpolasyonunu sağlar.</p>
                    
                    <h3>Bilgisayar Grafiği</h3>
                    <p>Karakter animasyonunda eklem dönüşümleri ve kamera hareketlerinde kullanılır.</p>
                    
                    <h3>Sanal Gerçeklik</h3>
                    <p>Kullanıcı etkileşimlerine dayalı gerçek zamanlı nesne manipülasyonu için idealdir.</p>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label for="application-select">Uygulama Senaryosu:</label>
                            <select id="application-select">
                                <option value="robot-arm">Robot Kolu Hareketi</option>
                                <option value="character-animation">Karakter Animasyonu</option>
                                <option value="camera-movement">Kamera Hareketi</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <button id="demo-application">Senaryoyu Göster</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="concept-cards">
            <div class="card">
                <h3>Geometrik Çarpım</h3>
                <p>İki vektörün geometrik çarpımı, hem iç çarpım hem de dış çarpım bilgisini içerir. Bu, dönüşümleri kompakt bir şekilde temsil etmeyi sağlar.</p>
            </div>
            
            <div class="card">
                <h3>Bivektörler</h3>
                <p>Bivektörler, yönlendirilmiş düzlemleri temsil eder. Örneğin, e₁∧e₂ bivektörü, e₁ ve e₂ vektörleri tarafından tanımlanan düzlemi temsil eder.</p>
            </div>
            
            <div class="card">
                <h3>Dual Sayılar</h3>
                <p>Dual sayılar, x + εy formundadır ve ε² = 0 kuralına uyar. Bu yapı, konum ve yön bilgisini birleştirmek için kullanılır.</p>
            </div>
            
            <div class="card">
                <h3>Study'nin Aktarım Prensibi</h3>
                <p>Birim dual küre üzerindeki bir nokta, 3B gerçek uzayda bir çizgiye karşılık gelir. Bu prensip, çizgilerin hareketini modellemek için kullanılır.</p>
            </div>
        </div>
        
        <footer>
            <p>Ferhat TAŞ'ın "Quaternion-based curves and surfaces for enhanced spatial motion generation using geometric algebra" makalesinden esinlenilmiştir.</p>
            <p>© 2023 Kuaterniyon Görselleştirici</p>
        </footer>
    </div>

    <script>
        // Three.js sahnesi, kamera ve renderer oluşturma
        let scene, camera, renderer, controls;
        let objects = [];
        let vectorU, vectorV, plane, demoObject;
        let currentTab = 'quaternions';
        
        function init() {
            // Sahne oluştur
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c0c2b);
            
            // Kamera oluştur
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.z = 5;
            
            // Renderer oluştur
            renderer = new THREE.WebGLRenderer({ antialias: true });
            const container = document.getElementById('three-container');
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // OrbitControls ekle
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Işıklandırma
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);
            
            // Koordinat eksenleri
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);
            
            // Izgara
            const gridHelper = new THREE.GridHelper(10, 10);
            scene.add(gridHelper);
            
            // Örnek nesneler oluştur
            createDemoObjects();
            
            // Pencere boyutu değiştiğinde renderer'ı güncelle
            window.addEventListener('resize', onWindowResize);
            
            // Animasyon döngüsü
            animate();
        }
        
        function createDemoObjects() {
            // Küre - orijin noktası
            const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);
            objects.push(sphere);
            
            // Vektör ok uçları
            const arrowGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
            const arrowMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            
            // Vektör u
            const arrowU = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrowU.position.set(1, 0, 0);
            arrowU.rotation.z = -Math.PI / 2;
            scene.add(arrowU);
            objects.push(arrowU);
            vectorU = arrowU;
            
            // Vektör v
            const arrowV = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrowV.position.set(0, 1, 0);
            arrowV.rotation.z = Math.PI;
            scene.add(arrowV);
            objects.push(arrowV);
            vectorV = arrowV;
            
            // Vektör çizgileri
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            
            const pointsU = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(1, 0, 0)
            ];
            const geometryU = new THREE.BufferGeometry().setFromPoints(pointsU);
            const lineU = new THREE.Line(geometryU, lineMaterial);
            scene.add(lineU);
            objects.push(lineU);
            
            const pointsV = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 1, 0)
            ];
            const geometryV = new THREE.BufferGeometry().setFromPoints(pointsV);
            const lineV = new THREE.Line(geometryV, lineMaterial);
            scene.add(lineV);
            objects.push(lineV);
            
            // Düzlem (bivektör) görselleştirme
            const planeGeometry = new THREE.PlaneGeometry(1, 1);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            scene.add(plane);
            objects.push(plane);
            
            // Demo nesnesi (döndürülebilir küp)
            const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const cubeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4488ff,
                transparent: true,
                opacity: 0.8
            });
            demoObject = new THREE.Mesh(cubeGeometry, cubeMaterial);
            demoObject.position.set(2, 0, 0);
            scene.add(demoObject);
            objects.push(demoObject);
        }
        
        function onWindowResize() {
            const container = document.getElementById('three-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Sekme değiştirme işlevi
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Tüm sekmeleri ve içerikleri devre dışı bırak
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Tıklanan sekme ve içeriği aktif yap
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(`${tabId}-content`).classList.add('active');
                
                // Güncel sekme bilgisini kaydet
                currentTab = tabId;
                
                // Görselleştirmeyi güncelle
                updateVisualization(tabId);
            });
        });
        
        function updateVisualization(tabId) {
            // Bu fonksiyon, sekmeye göre görselleştirmeyi günceller
            switch(tabId) {
                case 'quaternions':
                    // Kuaterniyon dönüşümü için görselleştirme
                    break;
                case 'geometric-algebra':
                    // Geometrik cebir için görselleştirme
                    break;
                case 'dual-quaternions':
                    // Dual kuaterniyonlar için görselleştirme
                    break;
                case 'applications':
                    // Uygulamalar için görselleştirme
                    break;
            }
        }
        
        // Kuaterniyon dönüşümü için olay dinleyicileri
        document.getElementById('rotation-angle').addEventListener('input', function() {
            document.querySelector('#rotation-angle + .value-display').textContent = `${this.value}°`;
            applyQuaternionRotation();
        });
        
        document.getElementById('rotation-axis').addEventListener('change', function() {
            applyQuaternionRotation();
        });
        
        document.getElementById('animate-rotation').addEventListener('click', function() {
            animateRotation();
        });
        
        document.getElementById('reset-rotation').addEventListener('click', function() {
            document.getElementById('rotation-angle').value = 0;
            document.querySelector('#rotation-angle + .value-display').textContent = '0°';
            applyQuaternionRotation();
        });
        
        // Geometrik cebir için olay dinleyicileri
        document.getElementById('vector-u-x').addEventListener('input', function() {
            document.querySelector('#vector-u-x + .value-display').textContent = `x: ${this.value}`;
            updateVectors();
        });
        
        document.getElementById('vector-u-y').addEventListener('input', function() {
            document.querySelector('#vector-u-y + .value-display').textContent = `y: ${this.value}`;
            updateVectors();
        });
        
        document.getElementById('vector-u-z').addEventListener('input', function() {
            document.querySelector('#vector-u-z + .value-display').textContent = `z: ${this.value}`;
            updateVectors();
        });
        
        document.getElementById('vector-v-x').addEventListener('input', function() {
            document.querySelector('#vector-v-x + .value-display').textContent = `x: ${this.value}`;
            updateVectors();
        });
        
        document.getElementById('vector-v-y').addEventListener('input', function() {
            document.querySelector('#vector-v-y + .value-display').textContent = `y: ${this.value}`;
            updateVectors();
        });
        
        document.getElementById('vector-v-z').addEventListener('input', function() {
            document.querySelector('#vector-v-z + .value-display').textContent = `z: ${this.value}`;
            updateVectors();
        });
        
        // Dual kuaterniyonlar için olay dinleyicileri
        document.getElementById('screw-angle').addEventListener('input', function() {
            document.querySelector('#screw-angle + .value-display').textContent = `${this.value}°`;
            applyScrewMotion();
        });
        
        document.getElementById('screw-translation').addEventListener('input', function() {
            document.querySelector('#screw-translation + .value-display').textContent = `${this.value} birim`;
            applyScrewMotion();
        });
        
        document.getElementById('animate-screw').addEventListener('click', function() {
            animateScrewMotion();
        });
        
        // Uygulamalar için olay dinleyicileri
        document.getElementById('demo-application').addEventListener('click', function() {
            const scenario = document.getElementById('application-select').value;
            demoApplication(scenario);
        });
        
        // Kuaterniyon dönüşümü uygulama fonksiyonu
        function applyQuaternionRotation() {
            const angle = document.getElementById('rotation-angle').value * Math.PI / 180;
            const axis = document.getElementById('rotation-axis').value;
            
            let rotationAxis;
            switch(axis) {
                case 'x':
                    rotationAxis = new THREE.Vector3(1, 0, 0);
                    break;
                case 'y':
                    rotationAxis = new THREE.Vector3(0, 1, 0);
                    break;
                case 'z':
                    rotationAxis = new THREE.Vector3(0, 0, 1);
                    break;
                case 'custom':
                    rotationAxis = new THREE.Vector3(1, 1, 1).normalize();
                    break;
            }
            
            // Kuaterniyon oluştur
            const quaternion = new THREE.Quaternion();
            quaternion.setFromAxisAngle(rotationAxis, angle);
            
            // Demo nesnesine uygula
            demoObject.setRotationFromQuaternion(quaternion);
        }
        
        // Kuaterniyon dönüşümü animasyonu
        function animateRotation() {
            let angle = 0;
            const maxAngle = 360;
            const speed = 2; // derece/frame
            
            function animate() {
                angle += speed;
                if (angle > maxAngle) angle = 0;
                
                document.getElementById('rotation-angle').value = angle;
                document.querySelector('#rotation-angle + .value-display').textContent = `${angle}°`;
                applyQuaternionRotation();
                
                if (angle < maxAngle || currentTab !== 'quaternions') {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Vektörleri güncelleme fonksiyonu
        function updateVectors() {
            const ux = parseFloat(document.getElementById('vector-u-x').value);
            const uy = parseFloat(document.getElementById('vector-u-y').value);
            const uz = parseFloat(document.getElementById('vector-u-z').value);
            
            const vx = parseFloat(document.getElementById('vector-v-x').value);
            const vy = parseFloat(document.getElementById('vector-v-y').value);
            const vz = parseFloat(document.getElementById('vector-v-z').value);
            
            // Vektör u'yu güncelle
            vectorU.position.set(ux, uy, uz);
            
            // Vektör v'yi güncelle
            vectorV.position.set(vx, vy, vz);
            
            // Düzlemi güncelle (u ve v vektörlerinin oluşturduğu düzlem)
            updatePlane(ux, uy, uz, vx, vy, vz);
        }
        
        // Düzlemi güncelleme fonksiyonu
        function updatePlane(ux, uy, uz, vx, vy, vz) {
            const u = new THREE.Vector3(ux, uy, uz);
            const v = new THREE.Vector3(vx, vy, vz);
            
            // Düzlem normali (u ve v'nin çapraz çarpımı)
            const normal = new THREE.Vector3();
            normal.crossVectors(u, v);
            
            if (normal.length() > 0) {
                normal.normalize();
                
                // Düzlemin yönelimini ayarla
                plane.lookAt(normal);
                
                // Düzlemi u ve v vektörlerinin ortasına yerleştir
                const center = new THREE.Vector3();
                center.addVectors(u, v);
                center.multiplyScalar(0.5);
                plane.position.copy(center);
            }
        }
        
        // Vida hareketi uygulama fonksiyonu
        function applyScrewMotion() {
            const angle = document.getElementById('screw-angle').value * Math.PI / 180;
            const translation = parseFloat(document.getElementById('screw-translation').value);
            
            // Dönüşümü uygula
            demoObject.rotation.z = angle;
            demoObject.position.x = 2 + translation;
        }
        
        // Vida hareketi animasyonu
        function animateScrewMotion() {
            let angle = 0;
            let translation = 0;
            const maxAngle = 360;
            const maxTranslation = 3;
            const angleSpeed = 2; // derece/frame
            const translationSpeed = 0.03; // birim/frame
            
            function animate() {
                angle += angleSpeed;
                translation += translationSpeed;
                
                if (angle > maxAngle) angle = 0;
                if (translation > maxTranslation) translation = 0;
                
                document.getElementById('screw-angle').value = angle;
                document.querySelector('#screw-angle + .value-display').textContent = `${angle}°`;
                
                document.getElementById('screw-translation').value = translation;
                document.querySelector('#screw-translation + .value-display').textContent = `${translation.toFixed(1)} birim`;
                
                applyScrewMotion();
                
                if ((angle < maxAngle || translation < maxTranslation) && currentTab === 'dual-quaternions') {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Uygulama senaryosu gösterimi
        function demoApplication(scenario) {
            // Senaryoya göre farklı animasyonlar
            switch(scenario) {
                case 'robot-arm':
                    // Robot kolu animasyonu
                    animateRobotArm();
                    break;
                case 'character-animation':
                    // Karakter animasyonu
                    animateCharacter();
                    break;
                case 'camera-movement':
                    // Kamera hareketi
                    animateCamera();
                    break;
            }
        }
        
        // Basit robot kolu animasyonu
        function animateRobotArm() {
            let angle = 0;
            const maxAngle = 90;
            const speed = 1; // derece/frame
            
            function animate() {
                angle += speed;
                if (angle > maxAngle) angle = 0;
                
                // Basit bir dönüşüm uygula
                demoObject.rotation.x = angle * Math.PI / 180;
                demoObject.position.y = Math.sin(angle * Math.PI / 180) * 2;
                
                if (angle < maxAngle && currentTab === 'applications') {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Basit karakter animasyonu
        function animateCharacter() {
            let angle = 0;
            const maxAngle = 45;
            const speed = 1; // derece/frame
            
            function animate() {
                angle += speed;
                if (angle > maxAngle) angle = -maxAngle;
                
                // Basit bir salınım uygula
                demoObject.rotation.z = angle * Math.PI / 180;
                
                if (currentTab === 'applications') {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Basit kamera hareketi
        function animateCamera() {
            let angle = 0;
            const radius = 5;
            const speed = 1; // derece/frame
            
            function animate() {
                angle += speed * Math.PI / 180;
                
                // Kamerayı daire şeklinde hareket ettir
                camera.position.x = radius * Math.cos(angle);
                camera.position.z = radius * Math.sin(angle);
                camera.lookAt(0, 0, 0);
                
                if (currentTab === 'applications') {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Uygulamayı başlat
        init();
    </script>
</body>
</html>